% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reactive-cached.R
\name{cachedReactive}
\alias{cachedReactive}
\title{Create a reactive expression with caching}
\usage{
cachedReactive(
  cacheKeyExpr,
  valueExpr,
  ...,
  domain = getDefaultReactiveDomain(),
  cache = "app"
)
}
\arguments{
\item{cacheKeyExpr}{An expression that returns a value that will be hashed
and used as a cache key. This key should be a unique identifier for the
value: the assumption is that if the cache key is the same, then the value
of \code{expr} is the same. If two separate \code{cachedReactive}s have the same key,
the value is assumed to be the same. To avoid this, you can add an
arbitrary identifier (like an ID string) to the cache key.}

\item{valueExpr}{The expression that produces the return value of the
\code{cachedReactive}. It will be executed within an \code{\link[=isolate]{isolate()}} scope.}

\item{...}{Other arguments are ignored.}

\item{domain}{See \link{domains}.}

\item{cache}{The scope of the cache, or a cache object. This can be \code{"app"}
(the default), \code{"session"}, or a cache object like a \code{\link[=diskCache]{diskCache()}}. See the
Cache Scoping section for more information.}
}
\description{
Create a reactive expression with caching
}
\examples{
## Only run examples in interactive R sessions
if (interactive()) {

# Basic example
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    "x * y: ",
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- cachedReactive(
      # Use input$x and input$y for the cache key. This is a reactive
      # expression
      list(input$x, input$y),
      {
        # The value expression is an expensive computation
        message("Doing expensive computation...")
        Sys.sleep(2)
        input$x * input$y
      }
    )
    output$txt <- renderText(r())
  }
)


# Demo of cache key collisions and how to avoid them
shinyApp(
  ui = fluidPage(
    numericInput("n", "n", 1),
    "n * 2: ", verbatimTextOutput("txt2"),
    "n * 3: ", verbatimTextOutput("txt3"),
    "n * 4: ", verbatimTextOutput("txt4")

  ),
  server = function(input, output) {
    r2 <- cachedReactive(input$n, {
      input$n * 2
    })
    output$txt2 <- renderText(r2())

    # BAD: This uses the same cache key as r2 above, and so it will collide with
    # r2.
    r3 <- cachedReactive(input$n, {
      input$n * 3
    })
    output$txt3 <- renderText(r3())

    # GOOD: By adding an ID string,this uses a different cache key from r2,
    # and so its keys will not collide with those from r2.
    r4 <- cachedReactive(list(input$n, "times4"), {
      input$n * 4
    })
    output$txt4 <- renderText(r4())
  }
)

}

}
